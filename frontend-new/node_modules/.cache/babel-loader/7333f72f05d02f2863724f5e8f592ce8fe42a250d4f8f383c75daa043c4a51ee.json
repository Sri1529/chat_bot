{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\nconst useChat = () => {\n  _s();\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [sessionId, setSessionId] = useState(null);\n  const sendMessage = useCallback(async (message, options = {}) => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId || options.sessionId,\n          stream: options.stream || false\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n        return {\n          response: data.data.response,\n          sessionId: data.data.sessionId,\n          contextFound: data.data.contextFound,\n          contextChunks: data.data.contextChunks,\n          timestamp: data.data.timestamp\n        };\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send message';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n  const sendStreamingMessage = useCallback(async (message, onChunk, onComplete, onError) => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      // Use regular chat endpoint instead of streaming\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n\n        // Simulate streaming by breaking the response into chunks\n        const responseText = data.data.message;\n        const words = responseText.split(' ');\n\n        // Send chunks word by word\n        for (let i = 0; i < words.length; i++) {\n          const word = words[i] + (i < words.length - 1 ? ' ' : '');\n          if (onChunk) onChunk(word);\n          // Small delay to simulate streaming\n          await new Promise(resolve => setTimeout(resolve, 50));\n        }\n        if (onComplete) onComplete(data.data.sessionId);\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send streaming message';\n      setError(errorMessage);\n      if (onError) onError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n  const getChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/history/${sessionIdToUse}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        return data.data.messages;\n      } else {\n        throw new Error(data.error || 'Failed to get chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to get chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n  const clearChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/reset/${sessionIdToUse}`, {\n        method: 'DELETE'\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        // Reset local session ID if clearing current session\n        if (sessionIdToUse === sessionId) {\n          setSessionId(null);\n        }\n        return true;\n      } else {\n        throw new Error(data.error || 'Failed to clear chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to clear chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n  const resetSession = useCallback(() => {\n    setSessionId(null);\n    setError(null);\n  }, []);\n  return {\n    sendMessage,\n    sendStreamingMessage,\n    getChatHistory,\n    clearChatHistory,\n    resetSession,\n    sessionId,\n    isLoading,\n    error\n  };\n};\n_s(useChat, \"UEDGf/h+psrk56MmrrbnrWH42OI=\");\nexport default useChat;","map":{"version":3,"names":["useState","useCallback","API_BASE_URL","process","env","REACT_APP_API_URL","useChat","_s","isLoading","setIsLoading","error","setError","sessionId","setSessionId","sendMessage","message","options","response","fetch","method","headers","body","JSON","stringify","stream","ok","Error","status","data","json","success","contextFound","contextChunks","timestamp","err","errorMessage","sendStreamingMessage","onChunk","onComplete","onError","responseText","words","split","i","length","word","Promise","resolve","setTimeout","getChatHistory","sessionIdToUse","messages","clearChatHistory","resetSession"],"sources":["/Users/agmac20/Downloads/voicebot-main/frontend-new/src/hooks/useChat.js"],"sourcesContent":["import { useState, useCallback } from 'react';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\n\nconst useChat = () => {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [sessionId, setSessionId] = useState(null);\n\n  const sendMessage = useCallback(async (message, options = {}) => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId || options.sessionId,\n          stream: options.stream || false\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n        \n        return {\n          response: data.data.response,\n          sessionId: data.data.sessionId,\n          contextFound: data.data.contextFound,\n          contextChunks: data.data.contextChunks,\n          timestamp: data.data.timestamp\n        };\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send message';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n\n  const sendStreamingMessage = useCallback(async (message, onChunk, onComplete, onError) => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      // Use regular chat endpoint instead of streaming\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n        \n        // Simulate streaming by breaking the response into chunks\n        const responseText = data.data.message;\n        const words = responseText.split(' ');\n        \n        // Send chunks word by word\n        for (let i = 0; i < words.length; i++) {\n          const word = words[i] + (i < words.length - 1 ? ' ' : '');\n          if (onChunk) onChunk(word);\n          // Small delay to simulate streaming\n          await new Promise(resolve => setTimeout(resolve, 50));\n        }\n        \n        if (onComplete) onComplete(data.data.sessionId);\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send streaming message';\n      setError(errorMessage);\n      if (onError) onError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n\n  const getChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/history/${sessionIdToUse}`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        return data.data.messages;\n      } else {\n        throw new Error(data.error || 'Failed to get chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to get chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n\n  const clearChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/reset/${sessionIdToUse}`, {\n        method: 'DELETE'\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        // Reset local session ID if clearing current session\n        if (sessionIdToUse === sessionId) {\n          setSessionId(null);\n        }\n        return true;\n      } else {\n        throw new Error(data.error || 'Failed to clear chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to clear chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n\n  const resetSession = useCallback(() => {\n    setSessionId(null);\n    setError(null);\n  }, []);\n\n  return {\n    sendMessage,\n    sendStreamingMessage,\n    getChatHistory,\n    clearChatHistory,\n    resetSession,\n    sessionId,\n    isLoading,\n    error\n  };\n};\n\nexport default useChat;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}