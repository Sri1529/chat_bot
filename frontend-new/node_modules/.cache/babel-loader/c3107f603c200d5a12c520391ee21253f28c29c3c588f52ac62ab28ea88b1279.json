{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\nconst useChat = () => {\n  _s();\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [sessionId, setSessionId] = useState(null);\n  const sendMessage = useCallback(async (message, options = {}) => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId || options.sessionId,\n          stream: options.stream || false\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n        return {\n          response: data.data.response,\n          sessionId: data.data.sessionId,\n          contextFound: data.data.contextFound,\n          contextChunks: data.data.contextChunks,\n          timestamp: data.data.timestamp\n        };\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send message';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n  const sendStreamingMessage = useCallback(async (message, onChunk, onComplete, onError) => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/stream`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let currentSessionId = sessionId;\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) break;\n        const chunk = decoder.decode(value);\n        const lines = chunk.split('\\n');\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            try {\n              const data = JSON.parse(line.slice(6));\n              switch (data.type) {\n                case 'session':\n                  currentSessionId = data.sessionId;\n                  if (!sessionId) {\n                    setSessionId(data.sessionId);\n                  }\n                  break;\n                case 'context':\n                  // Context information received\n                  break;\n                case 'chunk':\n                  if (onChunk) onChunk(data.text);\n                  break;\n                case 'complete':\n                  if (onComplete) onComplete(data.sessionId);\n                  break;\n                case 'error':\n                  throw new Error(data.message);\n              }\n            } catch (parseError) {\n              console.warn('Failed to parse SSE data:', parseError);\n            }\n          }\n        }\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send streaming message';\n      setError(errorMessage);\n      if (onError) onError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n  const getChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/history/${sessionIdToUse}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        return data.data.messages;\n      } else {\n        throw new Error(data.error || 'Failed to get chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to get chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n  const clearChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/reset/${sessionIdToUse}`, {\n        method: 'DELETE'\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        // Reset local session ID if clearing current session\n        if (sessionIdToUse === sessionId) {\n          setSessionId(null);\n        }\n        return true;\n      } else {\n        throw new Error(data.error || 'Failed to clear chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to clear chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n  const resetSession = useCallback(() => {\n    setSessionId(null);\n    setError(null);\n  }, []);\n  return {\n    sendMessage,\n    sendStreamingMessage,\n    getChatHistory,\n    clearChatHistory,\n    resetSession,\n    sessionId,\n    isLoading,\n    error\n  };\n};\n_s(useChat, \"UEDGf/h+psrk56MmrrbnrWH42OI=\");\nexport default useChat;","map":{"version":3,"names":["useState","useCallback","API_BASE_URL","process","env","REACT_APP_API_URL","useChat","_s","isLoading","setIsLoading","error","setError","sessionId","setSessionId","sendMessage","message","options","response","fetch","method","headers","body","JSON","stringify","stream","ok","Error","status","data","json","success","contextFound","contextChunks","timestamp","err","errorMessage","sendStreamingMessage","onChunk","onComplete","onError","reader","getReader","decoder","TextDecoder","currentSessionId","done","value","read","chunk","decode","lines","split","line","startsWith","parse","slice","type","text","parseError","console","warn","getChatHistory","sessionIdToUse","messages","clearChatHistory","resetSession"],"sources":["/Users/agmac20/Downloads/voicebot-main/frontend-new/src/hooks/useChat.js"],"sourcesContent":["import { useState, useCallback } from 'react';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\n\nconst useChat = () => {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [sessionId, setSessionId] = useState(null);\n\n  const sendMessage = useCallback(async (message, options = {}) => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId || options.sessionId,\n          stream: options.stream || false\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n        \n        return {\n          response: data.data.response,\n          sessionId: data.data.sessionId,\n          contextFound: data.data.contextFound,\n          contextChunks: data.data.contextChunks,\n          timestamp: data.data.timestamp\n        };\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send message';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n\n  const sendStreamingMessage = useCallback(async (message, onChunk, onComplete, onError) => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/stream`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let currentSessionId = sessionId;\n\n      while (true) {\n        const { done, value } = await reader.read();\n        \n        if (done) break;\n\n        const chunk = decoder.decode(value);\n        const lines = chunk.split('\\n');\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            try {\n              const data = JSON.parse(line.slice(6));\n              \n              switch (data.type) {\n                case 'session':\n                  currentSessionId = data.sessionId;\n                  if (!sessionId) {\n                    setSessionId(data.sessionId);\n                  }\n                  break;\n                case 'context':\n                  // Context information received\n                  break;\n                case 'chunk':\n                  if (onChunk) onChunk(data.text);\n                  break;\n                case 'complete':\n                  if (onComplete) onComplete(data.sessionId);\n                  break;\n                case 'error':\n                  throw new Error(data.message);\n              }\n            } catch (parseError) {\n              console.warn('Failed to parse SSE data:', parseError);\n            }\n          }\n        }\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send streaming message';\n      setError(errorMessage);\n      if (onError) onError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n\n  const getChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/history/${sessionIdToUse}`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        return data.data.messages;\n      } else {\n        throw new Error(data.error || 'Failed to get chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to get chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n\n  const clearChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/reset/${sessionIdToUse}`, {\n        method: 'DELETE'\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        // Reset local session ID if clearing current session\n        if (sessionIdToUse === sessionId) {\n          setSessionId(null);\n        }\n        return true;\n      } else {\n        throw new Error(data.error || 'Failed to clear chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to clear chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n\n  const resetSession = useCallback(() => {\n    setSessionId(null);\n    setError(null);\n  }, []);\n\n  return {\n    sendMessage,\n    sendStreamingMessage,\n    getChatHistory,\n    clearChatHistory,\n    resetSession,\n    sessionId,\n    isLoading,\n    error\n  };\n};\n\nexport default useChat;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}