{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect } from 'react';\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\nconst useChat = () => {\n  _s();\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [sessionId, setSessionId] = useState(() => {\n    // Load session ID from localStorage on initialization\n    return localStorage.getItem('chatSessionId') || null;\n  });\n  const [chatHistory, setChatHistory] = useState([]);\n\n  // Save session ID to localStorage whenever it changes\n  useEffect(() => {\n    if (sessionId) {\n      localStorage.setItem('chatSessionId', sessionId);\n    } else {\n      localStorage.removeItem('chatSessionId');\n    }\n  }, [sessionId]);\n\n  // Load chat history when session ID is available\n  useEffect(() => {\n    if (sessionId) {\n      loadChatHistory();\n    }\n  }, [sessionId]);\n  const loadChatHistory = useCallback(async () => {\n    if (!sessionId) return;\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/history/${sessionId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        setChatHistory(data.data.messages || []);\n      }\n    } catch (err) {\n      console.error('Failed to load chat history:', err);\n    }\n  }, [sessionId]);\n  const sendMessage = useCallback(async (message, options = {}) => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId || options.sessionId,\n          stream: options.stream || false\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        var _data$data$metadata, _data$data$metadata2;\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n\n        // Reload chat history to get the latest messages\n        if (data.data.sessionId) {\n          await loadChatHistory();\n        }\n        return {\n          response: data.data.message,\n          sessionId: data.data.sessionId,\n          contextFound: ((_data$data$metadata = data.data.metadata) === null || _data$data$metadata === void 0 ? void 0 : _data$data$metadata.hasContext) || false,\n          contextChunks: ((_data$data$metadata2 = data.data.metadata) === null || _data$data$metadata2 === void 0 ? void 0 : _data$data$metadata2.articles) || [],\n          timestamp: data.data.timestamp\n        };\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send message';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n  const sendStreamingMessage = useCallback(async (message, onChunk, onComplete, onError) => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      // Use regular chat endpoint instead of streaming\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n\n        // Simulate streaming by breaking the response into chunks\n        const responseText = data.data.message;\n        const words = responseText.split(' ');\n        console.log('words', words);\n        // Send chunks word by word\n        for (let i = 0; i < words.length; i++) {\n          const word = words[i] + (i < words.length - 1 ? ' ' : '');\n          if (onChunk) onChunk(word);\n          // Small delay to simulate streaming\n          await new Promise(resolve => setTimeout(resolve, 50));\n        }\n\n        // Reload chat history to get the latest messages\n        if (data.data.sessionId) {\n          await loadChatHistory();\n        }\n        if (onComplete) onComplete(data.data.sessionId);\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send streaming message';\n      setError(errorMessage);\n      if (onError) onError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n  const getChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/history/${sessionIdToUse}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        return data.data.messages;\n      } else {\n        throw new Error(data.error || 'Failed to get chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to get chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n  const clearChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/reset/${sessionIdToUse}`, {\n        method: 'DELETE'\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        // Clear local chat history\n        setChatHistory([]);\n        // Reset local session ID if clearing current session\n        if (sessionIdToUse === sessionId) {\n          setSessionId(null);\n        }\n        return true;\n      } else {\n        throw new Error(data.error || 'Failed to clear chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to clear chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n  const resetSession = useCallback(() => {\n    setSessionId(null);\n    setChatHistory([]);\n    setError(null);\n  }, []);\n  return {\n    sendMessage,\n    sendStreamingMessage,\n    getChatHistory,\n    clearChatHistory,\n    resetSession,\n    sessionId,\n    chatHistory,\n    isLoading,\n    error\n  };\n};\n_s(useChat, \"jeOonaIS0NtawJPHuyj1xIvZaSI=\");\nexport default useChat;","map":{"version":3,"names":["useState","useCallback","useEffect","API_BASE_URL","process","env","REACT_APP_API_URL","useChat","_s","isLoading","setIsLoading","error","setError","sessionId","setSessionId","localStorage","getItem","chatHistory","setChatHistory","setItem","removeItem","loadChatHistory","response","fetch","ok","Error","status","data","json","success","messages","err","console","sendMessage","message","options","method","headers","body","JSON","stringify","stream","_data$data$metadata","_data$data$metadata2","contextFound","metadata","hasContext","contextChunks","articles","timestamp","errorMessage","sendStreamingMessage","onChunk","onComplete","onError","responseText","words","split","log","i","length","word","Promise","resolve","setTimeout","getChatHistory","sessionIdToUse","clearChatHistory","resetSession"],"sources":["/Users/agmac20/Downloads/voicebot-main/frontend-new/src/hooks/useChat.js"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\n\nconst useChat = () => {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [sessionId, setSessionId] = useState(() => {\n    // Load session ID from localStorage on initialization\n    return localStorage.getItem('chatSessionId') || null;\n  });\n  const [chatHistory, setChatHistory] = useState([]);\n\n  // Save session ID to localStorage whenever it changes\n  useEffect(() => {\n    if (sessionId) {\n      localStorage.setItem('chatSessionId', sessionId);\n    } else {\n      localStorage.removeItem('chatSessionId');\n    }\n  }, [sessionId]);\n\n  // Load chat history when session ID is available\n  useEffect(() => {\n    if (sessionId) {\n      loadChatHistory();\n    }\n  }, [sessionId]);\n\n  const loadChatHistory = useCallback(async () => {\n    if (!sessionId) return;\n    \n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/history/${sessionId}`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        setChatHistory(data.data.messages || []);\n      }\n    } catch (err) {\n      console.error('Failed to load chat history:', err);\n    }\n  }, [sessionId]);\n\n  const sendMessage = useCallback(async (message, options = {}) => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId || options.sessionId,\n          stream: options.stream || false\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n        \n        // Reload chat history to get the latest messages\n        if (data.data.sessionId) {\n          await loadChatHistory();\n        }\n        \n        return {\n          response: data.data.message,\n          sessionId: data.data.sessionId,\n          contextFound: data.data.metadata?.hasContext || false,\n          contextChunks: data.data.metadata?.articles || [],\n          timestamp: data.data.timestamp\n        };\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send message';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n\n  const sendStreamingMessage = useCallback(async (message, onChunk, onComplete, onError) => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      // Use regular chat endpoint instead of streaming\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n        \n        // Simulate streaming by breaking the response into chunks\n        const responseText = data.data.message;\n        const words = responseText.split(' ');\n        console.log('words',words);\n        // Send chunks word by word\n        for (let i = 0; i < words.length; i++) {\n          const word = words[i] + (i < words.length - 1 ? ' ' : '');\n          if (onChunk) onChunk(word);\n          // Small delay to simulate streaming\n          await new Promise(resolve => setTimeout(resolve, 50));\n        }\n        \n        // Reload chat history to get the latest messages\n        if (data.data.sessionId) {\n          await loadChatHistory();\n        }\n        \n        if (onComplete) onComplete(data.data.sessionId);\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send streaming message';\n      setError(errorMessage);\n      if (onError) onError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n\n  const getChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/history/${sessionIdToUse}`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        return data.data.messages;\n      } else {\n        throw new Error(data.error || 'Failed to get chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to get chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n\n  const clearChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/reset/${sessionIdToUse}`, {\n        method: 'DELETE'\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        // Clear local chat history\n        setChatHistory([]);\n        // Reset local session ID if clearing current session\n        if (sessionIdToUse === sessionId) {\n          setSessionId(null);\n        }\n        return true;\n      } else {\n        throw new Error(data.error || 'Failed to clear chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to clear chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n\n  const resetSession = useCallback(() => {\n    setSessionId(null);\n    setChatHistory([]);\n    setError(null);\n  }, []);\n\n  return {\n    sendMessage,\n    sendStreamingMessage,\n    getChatHistory,\n    clearChatHistory,\n    resetSession,\n    sessionId,\n    chatHistory,\n    isLoading,\n    error\n  };\n};\n\nexport default useChat;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}