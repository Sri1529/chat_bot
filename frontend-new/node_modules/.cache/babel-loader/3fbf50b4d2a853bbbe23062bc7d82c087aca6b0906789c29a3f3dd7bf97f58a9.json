{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect } from 'react';\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\nconst useChat = () => {\n  _s();\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [sessionId, setSessionId] = useState(() => {\n    // Load session ID from localStorage on initialization\n    return localStorage.getItem('chatSessionId') || null;\n  });\n  const [chatHistory, setChatHistory] = useState([]);\n\n  // Save session ID to localStorage whenever it changes\n  useEffect(() => {\n    if (sessionId) {\n      localStorage.setItem('chatSessionId', sessionId);\n    } else {\n      localStorage.removeItem('chatSessionId');\n    }\n  }, [sessionId]);\n\n  // Load chat history when session ID is available\n  useEffect(() => {\n    if (sessionId) {\n      loadChatHistory();\n    }\n  }, [sessionId]);\n  const sendMessage = useCallback(async (message, options = {}) => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId || options.sessionId,\n          stream: options.stream || false\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n        return {\n          response: data.data.response,\n          sessionId: data.data.sessionId,\n          contextFound: data.data.contextFound,\n          contextChunks: data.data.contextChunks,\n          timestamp: data.data.timestamp\n        };\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send message';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n  const sendStreamingMessage = useCallback(async (message, onChunk, onComplete, onError) => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      // Use regular chat endpoint instead of streaming\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n\n        // Simulate streaming by breaking the response into chunks\n        const responseText = data.data.message;\n        const words = responseText.split(' ');\n\n        // Send chunks word by word\n        for (let i = 0; i < words.length; i++) {\n          const word = words[i] + (i < words.length - 1 ? ' ' : '');\n          if (onChunk) onChunk(word);\n          // Small delay to simulate streaming\n          await new Promise(resolve => setTimeout(resolve, 50));\n        }\n        if (onComplete) onComplete(data.data.sessionId);\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send streaming message';\n      setError(errorMessage);\n      if (onError) onError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n  const getChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/history/${sessionIdToUse}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        return data.data.messages;\n      } else {\n        throw new Error(data.error || 'Failed to get chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to get chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n  const clearChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/reset/${sessionIdToUse}`, {\n        method: 'DELETE'\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.success) {\n        // Reset local session ID if clearing current session\n        if (sessionIdToUse === sessionId) {\n          setSessionId(null);\n        }\n        return true;\n      } else {\n        throw new Error(data.error || 'Failed to clear chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to clear chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n  const resetSession = useCallback(() => {\n    setSessionId(null);\n    setError(null);\n  }, []);\n  return {\n    sendMessage,\n    sendStreamingMessage,\n    getChatHistory,\n    clearChatHistory,\n    resetSession,\n    sessionId,\n    isLoading,\n    error\n  };\n};\n_s(useChat, \"RLY8ttbw9umektgBal784NpB4t0=\");\nexport default useChat;","map":{"version":3,"names":["useState","useCallback","useEffect","API_BASE_URL","process","env","REACT_APP_API_URL","useChat","_s","isLoading","setIsLoading","error","setError","sessionId","setSessionId","localStorage","getItem","chatHistory","setChatHistory","setItem","removeItem","loadChatHistory","sendMessage","message","options","response","fetch","method","headers","body","JSON","stringify","stream","ok","Error","status","data","json","success","contextFound","contextChunks","timestamp","err","errorMessage","sendStreamingMessage","onChunk","onComplete","onError","responseText","words","split","i","length","word","Promise","resolve","setTimeout","getChatHistory","sessionIdToUse","messages","clearChatHistory","resetSession"],"sources":["/Users/agmac20/Downloads/voicebot-main/frontend-new/src/hooks/useChat.js"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\n\nconst useChat = () => {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [sessionId, setSessionId] = useState(() => {\n    // Load session ID from localStorage on initialization\n    return localStorage.getItem('chatSessionId') || null;\n  });\n  const [chatHistory, setChatHistory] = useState([]);\n\n  // Save session ID to localStorage whenever it changes\n  useEffect(() => {\n    if (sessionId) {\n      localStorage.setItem('chatSessionId', sessionId);\n    } else {\n      localStorage.removeItem('chatSessionId');\n    }\n  }, [sessionId]);\n\n  // Load chat history when session ID is available\n  useEffect(() => {\n    if (sessionId) {\n      loadChatHistory();\n    }\n  }, [sessionId]);\n\n  const sendMessage = useCallback(async (message, options = {}) => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId || options.sessionId,\n          stream: options.stream || false\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n        \n        return {\n          response: data.data.response,\n          sessionId: data.data.sessionId,\n          contextFound: data.data.contextFound,\n          contextChunks: data.data.contextChunks,\n          timestamp: data.data.timestamp\n        };\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send message';\n      setError(errorMessage);\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n\n  const sendStreamingMessage = useCallback(async (message, onChunk, onComplete, onError) => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      // Use regular chat endpoint instead of streaming\n      const response = await fetch(`${API_BASE_URL}/chat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          message,\n          sessionId: sessionId\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        // Set session ID if not already set\n        if (!sessionId && data.data.sessionId) {\n          setSessionId(data.data.sessionId);\n        }\n        \n        // Simulate streaming by breaking the response into chunks\n        const responseText = data.data.message;\n        const words = responseText.split(' ');\n        \n        // Send chunks word by word\n        for (let i = 0; i < words.length; i++) {\n          const word = words[i] + (i < words.length - 1 ? ' ' : '');\n          if (onChunk) onChunk(word);\n          // Small delay to simulate streaming\n          await new Promise(resolve => setTimeout(resolve, 50));\n        }\n        \n        if (onComplete) onComplete(data.data.sessionId);\n      } else {\n        throw new Error(data.error || 'Failed to send message');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to send streaming message';\n      setError(errorMessage);\n      if (onError) onError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sessionId]);\n\n  const getChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/history/${sessionIdToUse}`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        return data.data.messages;\n      } else {\n        throw new Error(data.error || 'Failed to get chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to get chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n\n  const clearChatHistory = useCallback(async (sessionIdToUse = sessionId) => {\n    if (!sessionIdToUse) {\n      throw new Error('No session ID provided');\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/chat/reset/${sessionIdToUse}`, {\n        method: 'DELETE'\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        // Reset local session ID if clearing current session\n        if (sessionIdToUse === sessionId) {\n          setSessionId(null);\n        }\n        return true;\n      } else {\n        throw new Error(data.error || 'Failed to clear chat history');\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to clear chat history';\n      setError(errorMessage);\n      throw err;\n    }\n  }, [sessionId]);\n\n  const resetSession = useCallback(() => {\n    setSessionId(null);\n    setError(null);\n  }, []);\n\n  return {\n    sendMessage,\n    sendStreamingMessage,\n    getChatHistory,\n    clearChatHistory,\n    resetSession,\n    sessionId,\n    isLoading,\n    error\n  };\n};\n\nexport default useChat;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}