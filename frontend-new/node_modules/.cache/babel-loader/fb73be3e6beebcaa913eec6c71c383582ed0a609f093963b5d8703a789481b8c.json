{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef } from 'react';\nconst useAudioRecorder = () => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const [error, setError] = useState(null);\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const startRecording = useCallback(async () => {\n    try {\n      setError(null);\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          sampleRate: 44100\n        }\n      });\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm;codecs=opus'\n      });\n      mediaRecorderRef.current = mediaRecorder;\n      audioChunksRef.current = [];\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n      mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(audioChunksRef.current, {\n          type: 'audio/webm;codecs=opus'\n        });\n        setAudioBlob(audioBlob);\n\n        // Stop all tracks\n        stream.getTracks().forEach(track => track.stop());\n      };\n      mediaRecorder.start(100); // Collect data every 100ms\n      setIsRecording(true);\n    } catch (err) {\n      console.error('Error starting recording:', err);\n      setError('Failed to start recording. Please check microphone permissions.');\n    }\n  }, []);\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      setIsRecording(false);\n    }\n  }, [isRecording]);\n  const clearAudio = useCallback(() => {\n    setAudioBlob(null);\n    audioChunksRef.current = [];\n    setError(null);\n  }, []);\n  return {\n    startRecording,\n    stopRecording,\n    isRecording,\n    audioBlob,\n    error,\n    clearAudio\n  };\n};\n_s(useAudioRecorder, \"YCBCjojj9LMRK06vDs1IQP+mymc=\");\nexport default useAudioRecorder;","map":{"version":3,"names":["useState","useCallback","useRef","useAudioRecorder","_s","isRecording","setIsRecording","audioBlob","setAudioBlob","error","setError","mediaRecorderRef","audioChunksRef","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","sampleRate","mediaRecorder","MediaRecorder","mimeType","current","ondataavailable","event","data","size","push","onstop","Blob","type","getTracks","forEach","track","stop","start","err","console","stopRecording","clearAudio"],"sources":["/Users/agmac20/Downloads/voicebot-main/frontend-new/src/hooks/useAudioRecorder.js"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\n\nconst useAudioRecorder = () => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const [error, setError] = useState(null);\n  \n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n\n  const startRecording = useCallback(async () => {\n    try {\n      setError(null);\n      \n      const stream = await navigator.mediaDevices.getUserMedia({ \n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          sampleRate: 44100\n        } \n      });\n      \n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm;codecs=opus'\n      });\n      \n      mediaRecorderRef.current = mediaRecorder;\n      audioChunksRef.current = [];\n      \n      mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n      \n      mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(audioChunksRef.current, { \n          type: 'audio/webm;codecs=opus' \n        });\n        setAudioBlob(audioBlob);\n        \n        // Stop all tracks\n        stream.getTracks().forEach(track => track.stop());\n      };\n      \n      mediaRecorder.start(100); // Collect data every 100ms\n      setIsRecording(true);\n      \n    } catch (err) {\n      console.error('Error starting recording:', err);\n      setError('Failed to start recording. Please check microphone permissions.');\n    }\n  }, []);\n\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      setIsRecording(false);\n    }\n  }, [isRecording]);\n\n  const clearAudio = useCallback(() => {\n    setAudioBlob(null);\n    audioChunksRef.current = [];\n    setError(null);\n  }, []);\n\n  return {\n    startRecording,\n    stopRecording,\n    isRecording,\n    audioBlob,\n    error,\n    clearAudio\n  };\n};\n\nexport default useAudioRecorder;\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,WAAW,EAAEC,MAAM,QAAQ,OAAO;AAErD,MAAMC,gBAAgB,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC7B,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGN,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACO,SAAS,EAAEC,YAAY,CAAC,GAAGR,QAAQ,CAAC,IAAI,CAAC;EAChD,MAAM,CAACS,KAAK,EAAEC,QAAQ,CAAC,GAAGV,QAAQ,CAAC,IAAI,CAAC;EAExC,MAAMW,gBAAgB,GAAGT,MAAM,CAAC,IAAI,CAAC;EACrC,MAAMU,cAAc,GAAGV,MAAM,CAAC,EAAE,CAAC;EAEjC,MAAMW,cAAc,GAAGZ,WAAW,CAAC,YAAY;IAC7C,IAAI;MACFS,QAAQ,CAAC,IAAI,CAAC;MAEd,MAAMI,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QACvDC,KAAK,EAAE;UACLC,gBAAgB,EAAE,IAAI;UACtBC,gBAAgB,EAAE,IAAI;UACtBC,UAAU,EAAE;QACd;MACF,CAAC,CAAC;MAEF,MAAMC,aAAa,GAAG,IAAIC,aAAa,CAACT,MAAM,EAAE;QAC9CU,QAAQ,EAAE;MACZ,CAAC,CAAC;MAEFb,gBAAgB,CAACc,OAAO,GAAGH,aAAa;MACxCV,cAAc,CAACa,OAAO,GAAG,EAAE;MAE3BH,aAAa,CAACI,eAAe,GAAIC,KAAK,IAAK;QACzC,IAAIA,KAAK,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;UACvBjB,cAAc,CAACa,OAAO,CAACK,IAAI,CAACH,KAAK,CAACC,IAAI,CAAC;QACzC;MACF,CAAC;MAEDN,aAAa,CAACS,MAAM,GAAG,MAAM;QAC3B,MAAMxB,SAAS,GAAG,IAAIyB,IAAI,CAACpB,cAAc,CAACa,OAAO,EAAE;UACjDQ,IAAI,EAAE;QACR,CAAC,CAAC;QACFzB,YAAY,CAACD,SAAS,CAAC;;QAEvB;QACAO,MAAM,CAACoB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;MACnD,CAAC;MAEDf,aAAa,CAACgB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;MAC1BhC,cAAc,CAAC,IAAI,CAAC;IAEtB,CAAC,CAAC,OAAOiC,GAAG,EAAE;MACZC,OAAO,CAAC/B,KAAK,CAAC,2BAA2B,EAAE8B,GAAG,CAAC;MAC/C7B,QAAQ,CAAC,iEAAiE,CAAC;IAC7E;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAM+B,aAAa,GAAGxC,WAAW,CAAC,MAAM;IACtC,IAAIU,gBAAgB,CAACc,OAAO,IAAIpB,WAAW,EAAE;MAC3CM,gBAAgB,CAACc,OAAO,CAACY,IAAI,CAAC,CAAC;MAC/B/B,cAAc,CAAC,KAAK,CAAC;IACvB;EACF,CAAC,EAAE,CAACD,WAAW,CAAC,CAAC;EAEjB,MAAMqC,UAAU,GAAGzC,WAAW,CAAC,MAAM;IACnCO,YAAY,CAAC,IAAI,CAAC;IAClBI,cAAc,CAACa,OAAO,GAAG,EAAE;IAC3Bf,QAAQ,CAAC,IAAI,CAAC;EAChB,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO;IACLG,cAAc;IACd4B,aAAa;IACbpC,WAAW;IACXE,SAAS;IACTE,KAAK;IACLiC;EACF,CAAC;AACH,CAAC;AAACtC,EAAA,CAzEID,gBAAgB;AA2EtB,eAAeA,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}